package MS::CV;

use strict;
use warnings;

use Carp;
use Exporter qw/import/;
use File::ShareDir qw/dist_file/;
use Storable;

my  $terms;
my  %exports;
my  %roots;
our %EXPORT_TAGS;
our @EXPORT_OK;

BEGIN {

    # read in ontology file
    my $fn_obo = dist_file('MS' => 'cv.stor');
    $terms = retrieve $fn_obo;

    # necessary for symbol table manipulation
    no strict 'refs';
    
    # generate constants and track root terms
    for my $id (keys %{$terms} ) {

        my $ref = $terms->{$id};
        my $const_name = $ref->{constant} ;
        next if (! defined $const_name);
        my $cv = $ref->{cv};
        die "name undefined for $id" if (! defined $const_name);

        # define constant
        *$const_name = sub () {$id};

        push @{ $exports{$cv} }, $const_name;
        push @MS::CV::EXPORT_OK, $const_name;
        push @{$roots{$cv} }, $id if (! exists $ref->{is_a});

    } 

    use strict 'refs';

    # update exportable constants and functions
    %MS::CV::EXPORT_TAGS = map {$_ => \@{ $exports{$_} }} keys %exports;
    push @MS::CV::EXPORT_OK, qw/is_a print_tree units_for regex_for/;

} # end BEGIN


sub is_a {
    
    my ($child, $parent) = @_;

    return undef if (! defined $terms->{$child});
    return 0 if (! defined $terms->{$child}->{is_a});

    my @parents = @{ $terms->{$child}->{is_a} };
    my $retval = 0;
    for (@parents) {
        return 1 if ($_ eq $parent);
        $retval += is_a( $_ => $parent );
    }
    return $retval ? 1 : 0;

}

sub units_for {

    my ($id) = @_;

    return undef if (! defined $terms->{$id}->{has_units});
    return [ @{ $terms->{$id}->{has_units} } ];

}

sub regex_for {

    my ($id) = @_;

    return undef if (! defined $terms->{$id}->{has_regexp});
    croak "Multiple regular expressions not supported for $id\n"
        if (defined $terms->{$id}->{has_regexp}->[1]);
    my $rid = $terms->{$id}->{has_regexp}->[0];
    return qr/$terms->{$rid}->{name}/;

}

sub print_tree {

    my ($cv, $level, @parents) = @_;

    croak "CV $cv not valid" if (! defined $roots{$cv});

    $level = $level // 0;
    if (! @parents) {
        @parents = @{ $roots{$cv} };
    }

    for my $parent (@parents) {
        next if (! defined $terms->{$parent}->{constant});
        print "---" x $level . $parent,
        "\t" . $terms->{$parent}->{name},
        "\t" . $terms->{$parent}->{constant}, "\n";
        ++$level;
        if (defined $terms->{$parent}->{children}) {
            print_tree ($cv, $level, keys %{ $terms->{$parent}->{children}});
        }
        --$level;
    }
    return;

}

1;


__END__

=head1 NAME

MS::CV - interface to HUPO PSI controlled vocabularies

=head1 SYNOPSIS

    use MS::CV qw/:MS :MOD :MI is_a regex_for units_for/;

    # use PSI terms directly as constants
    if ('MS:1000894' eq MS_RETENTION_TIME) {
        # do something
    }

    # check for child/parent relationships
    print "model param is valid!\n"
        if ( is_a(MS_Q_TRAP, MS_INSTRUMENT_MODEL) );


    # PSI:MS conveniently provides cleavage regular expressions
    my $pep = 'PEPTIDERPEPTIDEKRAPPLE';
    my $re  = regex_for(MS_TRYPSIN);
    print "FRAG: $_\n" for split($tryp_re, $pep);


=head1 DESCRIPTION

C<MS::CV> provides a simple interface to the HUPO PSI controlled vocabularies.
Currently the MS, MOD, and MI ontologies are indexed and available.

The module utilizes a functional interface for speed and simplicity. It's
primarily functionality is to export sets of constants (one for each ontology)
directly mapping the term names to ids.

=head1 CONSTANT NAMING

Constant names are autogenerated from the C<name> field of the ontology OBO
files. The rules for mapping are defined in the following code:

    my $symb = uc( $ontology . '_' . $term->{name} );
    $symb =~ s/\W/_/g;
    $symb =~ s/^(\d)/_$1/;

For example, the term "CRM spectrum" in the MS ontology becomes C<MS_CRM_SPECTRUM>.

In addition, very rarely there are namespace collisions between terms after
applying these transformations. In this case, increasing integer suffixes are
appended to each colliding term. As of this writing, this only occurs for the
following terms:

=over 4
    
=item MOD_DESMOSINE
    
MOD:00949 ("desmosine") becomes MOD_DESMOSINE_1

MOD:01933 ("desmosine") becomes MOD_DESMOSINE_2

=item MI_TEXT_MINING
    
MI:0110 ("text mining") becomes MI_TEXT_MINING_1

MI:1056 ("text-mining") becomes MI_TEXT_MINING_2

=item MI_OPPOSING_EPISTASIS
    
MI:1276 ("opposing epistasis") becomes MI_OPPOSING_EPISTASIS_1

MI:1285 ("opposing epistasis") becomes MI_OPPOSING_EPISTASIS_2

=back

=head1 FUNCTIONS

=over 4

=item B<elem_mass> I<symbol> [I<type>]

    use constant PROTON     => elem_mass('H');
    use constant PROTON_AVG => elem_mass('H', 'average');

Takes one required argument (an element symbol) and
one optional argument (the mass value to return, either 'mono' or 'average')
and returns the associated mass value. By default, the monoisotopic mass is
returned. Element symbols are case-sensitive;

=item B<aa_mass> I<code> [I<type>]

    use constant PROLINE     => aa_mass('P');
    use constant PROLINE_AVG => aa_mass('P', 'average');

Takes one required argument (the 1-letter IUPAC code for an amino acid) and
one optional argument (the mass value to return, either 'mono' or 'average')
and returns the associated mass value. By default, the monoisotopic mass is
returned.

=item B<mod_mass> I<name> [I<type>]

    use constant DEAM     => mod_mass('Deamidated');
    use constant DEAM_AVG => brick_mass('Deamidated', average');

Takes one required argument (the modification name) and one optional argument (the
mass value to return, either 'mono' or 'average') and returns the associated
mass value. By default, the monoisotopic mass is returned.

=item B<brick_mass> I<name> [I<type>]

    use constant WATER     => brick_mass('Water');
    use constant WATER_AVG => brick_mass('Water', average');

Takes one required argument (the brick name) and one optional argument (the
mass value to return, either 'mono' or 'average') and returns the associated
mass value. By default, the monoisotopic mass is returned. See C<list_bricks>
for more details.

=item B<formula_mass> I<formula> [I<type>]

Takes one required argument (a string containing a chemical formula) and one
optional argument (the mass value to return, either 'mono' or 'average') and
returns the associated mass value. By default, the monoisotopic mass is
returned.

Formulas are case-sensitive, for obvious reasons. Currently grouping is not
supported. For example, to get the formula for Al2(SO4)3 you must flatten it
out:

    my $al_sulf = formula_mass('Al2S3O12');

and not:

    my $al_sulf = formula_mass('Al2(SO4)3'); # this gives an error

Support for more complicated formulas may be added in the future.

=item B<atoms_mass> I<hashref> [I<type>]

Takes one required argument (a hashref containing element counts) and one
optional argument (the mass value to return, either 'mono' or 'average') and
returns the associated mass value. By default, the monoisotopic mass is
returned.

This function was added to make it easy to recalculate masses based on
modifying the return reference from C<atoms>.

=item B<atoms> I<type> I<name>

    my $atoms = $atoms('aa' => 'G');
    my $n_C = $atoms->{C};

Takes two required arguments (the record type - 'aa', 'mod', or 'brick' - and the
record name/symbol) and returns a hash reference where the keys are the
elements present in the molecule and the values are their counts.

=item B<mod_id_to_name> I<id>

    my $name = mod_id_to_name(7);
    my $deam = mod_mass($name);

Takes one required arguments (a Unimod modification record id) and returns the
associated name compatible with C<mod_mass> or undef if not found.

=item B<mod_data> I<id>

    my $mod = mod_data('Carbamidomethyl');
    my @specificities = @{ $mod->{'umod:specificity'} }
    for (@specificities) {
        print "$_->{site}\n" if (! $_->{hidden});
    }

Takes one required argument (a modification name) and returns a hash
reference containing a nested data structure with all information contained in
the Unimod record. Use Data::Dumper for a view of the internal structure.

In the future an object-oriented interface may be added to make access to
these details more user-friendly.

=item B<list_bricks>

    print {$ref_table} list_bricks();

This is a convenience function that returns a tab-separated table of available
Unimod "bricks" suitable for printing. These are elemental or molecular units
that can be referenced as a group for convenience.

This function is provided mainly because this information does not seem to be
readily available elsewhere without reading the XML.

=item B<db_version>

Returns the version string of the Unimod database in use.

=back

=head1 CAVEATS AND BUGS

Please report bugs to the author.

=head1 AUTHOR

Jeremy Volkening <jdv@base2bio.com>

=head1 COPYRIGHT AND LICENSE

Copyright 2016 Jeremy Volkening

This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see <http://www.gnu.org/licenses/>.

=cut

