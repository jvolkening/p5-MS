package MS::Parser;

use strict;
use warnings;

use Carp;
use Digest::MD5;
use Storable qw/nstore_fd retrieve_fd/;
use Scalar::Util qw/blessed/;
use PerlIO::gzip;

our $VERSION = 0.201;
$VERSION = eval $VERSION;

use constant BGZF_MAGIC => pack 'H*', '1f8b0804';

sub new {

    my ($class, $fn) = @_;

    my $self = bless {}, $class;
    $self->{version} = $VERSION;
    $self->load($fn) if (defined $fn);

    # check expected methods in subclasses
    $self->_check_interface;

    return $self;

}

# to be defined by subclass
sub _check_interface { return }

sub load {

    my ($self, $fn) = @_;

    croak "input file not found" if (! -e $fn);
    $self->{fn} = $fn;
    open my $fh, '<', $fn;
    my $old_layers = join '', map {":$_"} PerlIO::get_layers($fh);
    binmode $fh;

    # check for BGZIP compression
    read($fh, my $magic, 4);
    binmode($fh, $old_layers);
    if ($magic eq BGZF_MAGIC) {
        require Compress::BGZF::Reader
            or croak "Compress::BGZF::Reader required to handle BGZF files";
        close $fh;
        $fh = Compress::BGZF::Reader->new_filehandle($fn);
    }
    
    $self->{fh} = $fh;
    seek $fh, 0, 0;

    # Calculate MD5 on whole file (NOTE: currently addfile() (XS-based) will
    # fail on tied filehandle - don't use.
    my $d = Digest::MD5->new();
    while (my $r = read $fh, my $buf, 8192) {
        $d->add($buf);
    }
    my $checksum = $d->hexdigest;
    seek $fh, 0, 0;

    # Check for existing index. If present, compare checksums and load
    # existing index upon match. Croak if no match.
    my $fn_idx = $fn . '.idx';
    if (-r $fn_idx) {
        open my $fhi, '<:gzip', $fn_idx;
        my $existing = retrieve_fd($fhi);
        close $fhi;
        if ($existing->{version} < $VERSION) {
            croak "Index files were generated by an older version of "
            . blessed($self) . ". Not all versions are backwards compatible"
            . " - please remove the old indices and try again\n";
        }
        elsif ($checksum ne $existing->{md5sum}) {
            croak "MD5 check in existing index $fn_idx failed. If data file"
            . " has changed, please remove existing index and try again.\n";
        }
        %$self = %$existing;
        $self->{fh} = $fh;
        $self->{fn} = $fn;
        return;
    }

    # Otherwise, do full file parse and store index
    $self->{md5sum} = $checksum;

    # This is where the actual file parsing takes place. The _load_new()
    # method must be defined for each format-specific subclass.
    $self->_load_new;

    # Store data structure as index
    $self->write_index;

    return;

}

sub write_index {

    my ($self) = @_;

    my $tmp_fh = delete $self->{fh};
    my $fn_idx = $self->{fn} . '.idx';
    open my $fh, '>:gzip', $fn_idx;
    nstore_fd($self => $fh) or die "failed to store self: $!\n";
    close $fh;
    $self->{fh} = $tmp_fh;

    return;

}

1;

__END__

=head1 NAME

MS::Parser - Superclass for mass spectrometry file parsers

=head1 SYNOPSIS

    package MS::Parser::SomeFormat;

    use parent qw/MS::Parser/;

    sub _load_new {
        # must be defined - handles actual parsing of data
    }

    # other accessors / convenience functions

=head1 DESCRIPTION

C<MS::Parser> is the superclass from which most/all of the file parsers in the
distribution are derived. It's primary role is to handle storing and reading
of the "index" files (actually serialized and compressed object structures)
used by all subclasses. It also handles detection and loading of files
compressed with blocked GZIP (BGZF) using the L<Compress::BGZF> distribution.

For further information, see the POD for specific parser subclasses.

=head1 AUTHOR

Jeremy Volkening <jdv@base2bio.com>

=head1 COPYRIGHT AND LICENSE

Copyright 2015-2016 Jeremy Volkening

This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see <http://www.gnu.org/licenses/>.

=cut

