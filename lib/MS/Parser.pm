package MS::Parser;

use strict;
use warnings;

use Carp;
use Digest::MD5;
use Storable qw/store retrieve/;
use Scalar::Util qw/blessed/;

our $VERSION = 0.200;
$VERSION = eval $VERSION;

use constant BGZF_MAGIC => pack 'H*', '1f8b0804';

sub new {

    my ($class,$fn) = @_;

    my $self = bless {}, $class;
    $self->{version} = $VERSION;
    $self->load($fn) if (defined $fn);

    # check expected methods in subclasses
    $self->_check_interface;

    return $self;

}

# to be defined by subclass
sub _check_interface {
    return;
}

sub load {

    my ($self, $fn) = @_;

    croak "input file not found" if (! -e $fn);
    $self->{fn} = $fn;
    open my $fh, '<', $fn;
    my $old_layers = join '', map {":$_"} PerlIO::get_layers($fh);
    binmode $fh;

    # check for BGZIP compression
    read($fh, my $magic, 4);
    binmode($fh, $old_layers);
    if ($magic eq BGZF_MAGIC) {
        require Compress::BGZF::Reader
            or croak "Compress::BGZF::Reader required to handle BGZF files";
        close $fh;
        $fh = Compress::BGZF::Reader->new_filehandle($fn);
    }
    
    $self->{fh} = $fh;
    seek $fh, 0, 0;

    # Calculate MD5 on whole file (NOTE: currently addfile() (XS-based) will
    # fail on tied filehandle - don't use.
    my $d = Digest::MD5->new();
    while (my $r = read $fh, my $buf, 8192) {
        $d->add($buf);
    }
    my $checksum = $d->hexdigest;

    seek $fh, 0, 0;

    # Check for existing index. If present, compare checksums and load
    # existing index upon match. Croak if no match.
    my $fn_idx = $fn . '.idx';
    if (-r $fn_idx) {
        my $existing = retrieve($fn_idx);
        if ($existing->{version} < $VERSION) {
            croak "Index files were generated by an older version of "
            . blessed($self) . ". Not all versions are backwards compatible"
            . " - please remove the old indices and try again\n";
        }
        elsif ($checksum ne $existing->{md5sum}) {
            croak "MD5 check in existing index $fn_idx failed. If data file"
            . " has changed, please remove existing index and try again.\n";
        }
        %$self = %$existing;
        $self->{fh} = $fh;
        $self->{fn} = $fn;
        return 1;
    }

    # Otherwise, do full file parse and store index
    $self->{md5sum} = $checksum;

    # This is where the actual file parsing takes place. The _load_new()
    # method must be defined for each format-specific subclass.
    $self->_load_new;

    # Store data structure as index
    $self->write_index;

    return;

}

sub write_index {

    my ($self) = @_;

    my $tmp_fh = $self->{fh};
    $self->{fh} = undef;
    my $fn_idx = $self->{fn} . '.idx';
    store($self => $fn_idx) or die "failed to store self: $!\n";
    $self->{fh} = $tmp_fh;

    return;

}

1;
