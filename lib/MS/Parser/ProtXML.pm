package MS::Parser::ProtXML;

use strict;
use warnings;
use Digest::MD5;
use IO::Handle;
use XML::Twig;
use Storable qw/store retrieve/;
use Carp;
use MS::Parser::ProtXML::Group;

our $VERSION = 0.200;
use constant BGZF_MAGIC => pack 'H*', '1f8b0804';

# A few lookup tables to speed up checks
our %_skip_inside = map {$_ => 1} qw/
    protein_group
    mixturemodel
/;
our %_make_index = map {$_ => 1} qw/
    protein_group
/;

our %_name_value = (
    parameter    => ['name','value'],
);
our %_make_anon_array = map {$_ => 1} qw/
    analysis_summary
    nsp_distribution
    ni_distribution
    protein_summary_data_filter
/;

sub new {

    my ($class,$fn) = @_;
    my $self = bless {}, $class;
    $self->{MS_ProtXML_version} = $VERSION;
    $self->load($fn) if (defined $fn);
    return $self;

}

sub load {

    my ($self, $fn) = @_;

    croak "input file not found" if (! -e $fn);
    $self->{fn} = $fn;
    open my $fh, '<', $fn;
    my $old_layers = join '', map {":$_"} PerlIO::get_layers($fh);
    binmode $fh;

    # check for BGZIP compression
    read($fh, my $magic, 4);
    binmode($fh, $old_layers);
    if ($magic eq BGZF_MAGIC) {
        require Compress::BGZF::Reader
            or croak "Compress::BGZF::Reader required to handle BGZF files";
        close $fh;
        $fh = Compress::BGZF::Reader->new_filehandle($fn);
    }

    seek $fh, 0, 0;

    # Calculate MD5 on whole file (NOTE: currently addfile() (XS-based) will
    # fail on tied filehandle - don't use.
    my $d = Digest::MD5->new();
    while (my $r = read $fh, my $buf, 8192) {
        $d->add($buf);
    }
    my $checksum = $d->hexdigest;

    seek $fh, 0, 0;

    # Check for existing index. If present, compare checksums and load
    # existing index upon match. Croak if no match.
    my $fn_idx = $fn . '.idx';
    if (-r $fn_idx) {
        my $existing = retrieve($fn_idx);
        if ($existing->{MS_ProtXML_version} < $VERSION) {
            croak "Index files were generated by an older version of MS::Parser::ProtXML."
            . " Not all versions are backwards compatible - please remove the"
            . " old indices and try again\n";
        }
        elsif ($checksum ne $existing->{md5sum}) {
            croak "MD5 check in existing index $fn_idx failed. If protXML has"
            . " changed, please remove existing index and try again.\n";
        }
        $existing->{fh} = $fh;
        $existing->{fn} = $fn;
        %$self = %$existing;
        return;
    }

    # Otherwise, do full file parse and store index
    $self->{md5sum} = $checksum;

    $self->{_curr_ref} = $self;
    my $p = XML::Parser->new();
    $p->setHandlers(
        Start => sub{ $self->_handle_start( @_) },
        End   => sub{ $self->_handle_end( @_) },
        Char  => sub{ $self->_handle_char( @_) },
    );
    $p->parse($fh);
    seek $fh, 0, 0;

    $self->_tidy_up();

    # Store data structure as index (but not filehandle)
    $self->{fh} = undef;
    store $self, $fn_idx;
    $self->{fh} = $fh;

    # clean toplevel
    my $toplevel = 'protein_summary';
    $self->{$_} = $self->{$toplevel}->{$_}
        for (keys %{ $self->{$toplevel} });
    delete $self->{$toplevel};

    return;

}

sub _tidy_up {

    my ($self) = @_;
    
    # delete temporary entries (start with "_")
    for my $key (qw/_last_record _skip_parse _curr_ref/) {
        delete $self->{$key}
    }

    return;

}

sub _handle_start {

    my ($self, $p, $el, %attrs) = @_;

    # track offsets of certain items
    if ($_make_index{ $el }) {
        my $id = $attrs{group_number}
            or croak "'index' attribute missing on indexed element";
        $self->{offsets}->{$id} = $p->current_byte;
        if (defined $self->{_last_record}) {
            $self->{links}->{ $self->{_last_record} } = $id;
            $self->{backlinks}->{$id} = $self->{_last_record};
        }
        else {
            $self->{start_record} = $id;
            $self->{pos} = $id;
        }
        $self->{end_record}   = $id;
        $self->{_last_record} = $id;
    }

    # skip parsing inside certain elements
    if ($_skip_inside{ $el }) {
        $p->setHandlers(
            Start => undef,
            End   => sub{ $self->_handle_end( @_) },
            Char  => undef,
        );
        $self->{_skip_parse} = 1;
        return;
    }

    my $new_ref = {%attrs};
    $new_ref->{_back} = $self->{_curr_ref};
    
    # Elements that should be grouped by name/id
    if ($_name_value{ $el }) {

        my ($id_name, $val_name) = @{ $_name_value{ $el } };
        my $id  = $attrs{$id_name};
        my $val = $attrs{$val_name};
        $self->{_curr_ref}->{$el}->{$id} = $val
            if (! defined $self->{_curr_ref}->{$el}->{$id});
        delete $new_ref->{$id_name};
        delete $new_ref->{$val_name};

    }

    # Elements that should be grouped with no name
    elsif ( $_make_anon_array{ $el } ) {
        push @{ $self->{_curr_ref}->{$el} }, $new_ref;
    }

    # Everything else
    else {  
        $self->{_curr_ref}->{$el} = $new_ref;
    }
    $self->{_curr_ref} = $new_ref;

    return;

}

sub _handle_end {

    my ($self, $p, $el) = @_;

    if ($_make_index{$el}) {
        my $id = $self->{_last_record};
        my $offset = $self->{offsets}->{$id};
        $self->{lengths}->{$id} = $p->current_byte + length($el) + 3 - $offset;
    }

    if ($_skip_inside{$el}) {
        $p->setHandlers(
            Start => sub{ $self->_handle_start( @_) },
            End   => sub{ $self->_handle_end( @_) },
            Char  => sub{ $self->_handle_char( @_) },
        );
        delete $self->{_skip_parse};
        return;
    }

    return if ($self->{_skip_parse});

    # step back down linked list
    my $last_ref = $self->{_curr_ref}->{_back};
    delete $self->{_curr_ref}->{_back};
    $self->{_curr_ref} = $last_ref;

    return;


}

sub _handle_char {

    my ($self, $p, $data) = @_;
    $self->{_curr_ref}->{pcdata} .= $data
        if ($data =~ /\S/);
    return;

}

sub _read_element {

    my ($self, $offset, $to_read) = @_;

    seek $self->{fh}, $offset, 0;
    my $r = read($self->{fh}, my $el, $to_read);
    die "returned unexpected byte count" if ($r != $to_read);

    return $el;

}

sub next_group {

    my ($self) = @_;

    if (! defined $self->{pos}) {
        $self->{pos} = $self->{start_record};
        return undef;
    }
    my $idx = $self->{pos};
    my $q = $self->fetch_group( $self->{pos} );
    $self->{pos} = $self->{links}->{ $self->{pos} } // undef;
    return $q;

}

sub next_index {

    my ($self) = @_;

    if (! defined $self->{pos}) {
        $self->{pos} = $self->{start_record};
        return undef;
    }
    my $idx = $self->{pos};
    $self->{pos} = $self->{links}->{ $self->{pos} } // undef;
    return $idx;

}

sub fetch_group {

    my ($self, $query_num) = @_;

    my $offset  = $self->{offsets}->{ $query_num };
    die "offset $offset not defined" if (! defined $offset);
    my $to_read = $self->{lengths}->{ $query_num };

    my $el = $self->_read_element($offset, $to_read);

    return MS::Parser::ProtXML::Group->new(xml => $el);

}


1;
